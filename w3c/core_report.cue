// Core W3C use case report — generated via cue export.
//
// Usage:
//   cue export ./w3c/ -e core_report --out text > w3c/core-report.md
//
// Every JSON evidence block is computed from the inline graph
// defined in evidence.cue. The report IS the proof.
package w3c

import (
	"strings"

	"apercue.ca/vocab@v0"
)

// ── Spec table rows (computed from registry) ────────────────────

_spec_rows: [
	for name, s in vocab.Specs if s.status == "Implemented" {
		"| \(name) | \(s.coverage) |"
	},
]

_downstream_rows: [
	for name, s in vocab.Specs if s.status == "Downstream" {
		"| \(name) | \(s.coverage) |"
	},
]

// ── Core report ─────────────────────────────────────────────────

core_report: """
	# Compile-Time Linked Data: Full W3C Closure From a Single CUE Value

	**Use Case Report for W3C Community Groups**

	---

	## Abstract

	[CUE](https://cuelang.org)'s lattice-based unification simultaneously performs
	SPARQL-class graph pattern matching and SHACL constraint validation at compile
	time. A single typed dependency graph produces \(evidence.spec_counts.implemented) W3C
	specification outputs — including JSON-LD, SHACL, SKOS, OWL-Time, PROV-O, ODRL,
	and Verifiable Credentials — without runtime processors, triplestores, or
	pipelines. An \(evidence.spec_counts.total)th (Hydra) is implemented downstream.

	This report documents the implementation, provides computed evidence from a live
	example graph, and identifies relevance to four W3C Community Groups.

	**All evidence below is computed, not hand-written.** Each JSON block is
	generated by `cue export ./w3c/ -e evidence.<field>`. Reproduce from source:
	[github.com/quicue/apercue](https://github.com/quicue/apercue).

	## Problem Statement

	The semantic web stack traditionally requires five or more runtime components:
	an RDF store, a SPARQL query engine, a SHACL processor, a serializer, and a
	query planner. Each introduces its own execution model, failure modes, and
	infrastructure requirements. Schema drift between layers is common.

	For constrained domains — research data management, project plans, infrastructure
	topology, academic curricula — this operational complexity is disproportionate
	to the problem. These domains share a common structure: typed resources with directed
	acyclic dependency edges. They need standards-compliant output, not the full
	semantic web runtime.

	## Approach

	[apercue.ca](https://github.com/quicue/apercue) implements a constraint-based
	alternative using CUE, a configuration language with lattice-theoretic type
	semantics. Resources declare two things: what they are (`@type`, a
	struct-as-set) and what they need (`depends_on`, also a struct-as-set):

	```cue
	"analysis-code": {
	    name:       "analysis-code"
	    "@type":    {Process: true}
	    depends_on: {"sensor-dataset": true}
	}
	```

	Everything else — topology, impact analysis, compliance, scheduling, and every
	W3C output — is a projection of this single value.
	`cue export -e <expression>` produces the target format.

	## Implementation Evidence

	The inline example graph defines a 5-node research publication pipeline:
	ethics approval, sensor dataset, analysis code, draft paper, and peer review.
	This domain was chosen because W3C specifications map to their intended
	purposes: Dublin Core for publication metadata, PROV-O for dataset provenance,
	ODRL for data embargo policies, and OWL-Time for submission deadlines. This is
	the same `#Graph` pattern used in production deployments with 30+ nodes.

	### JSON-LD Context

	All evidence blocks share this `@context`, which maps resource fields to
	standard W3C vocabularies:

	```json
	\(_json.context)
	```

	This context is not a configuration file — it is a CUE value computed from
	the vocabulary registry. Every resource exported through this context produces
	valid JSON-LD 1.1.

	### SHACL Validation (computed)

	A compliance rule requires that publications have upstream dependencies
	(cannot exist without supporting data). The `#ComplianceCheck` pattern
	produces a standard `sh:ValidationReport`:

	```json
	\(_json.shacl)
	```

	`sh:conforms: true` — all compliance rules pass. This is produced at CUE
	evaluation time. No separate SHACL processor runs.

	### Critical Path / OWL-Time (computed)

	The `#CriticalPath` pattern computes forward/backward passes and identifies
	the critical sequence:

	```json
	\(_json.cpm_sequence)
	```

	\(evidence.cpm_summary.critical_count)-node critical path, \(evidence.cpm_summary.total_duration)-day total
	duration. The same data produces standard OWL-Time `time:Interval` entries:

	```json
	\(_json.time_entry)
	```

	Each resource becomes a `time:Interval` with `time:hasBeginning`,
	`time:hasEnd`, and `time:hasDuration`. Slack and criticality are extensions
	in the `apercue:` namespace.

	### Access Policy / ODRL (computed)

	The `#ODRLPolicy` pattern projects dependency-graph resources into an ODRL
	policy set:

	```json
	\(_json.odrl)
	```

	Permissions and prohibitions are typed by the same `@type` set that drives
	graph construction. Adding a policy is adding a CUE file, not configuring
	middleware.

	### Provenance / PROV-O (computed)

	The `#ProvenanceTrace` pattern maps dependency edges to `prov:wasDerivedFrom`
	relations:

	```json
	\(_json.prov_entity)
	```

	Every resource becomes a `prov:Entity`. Dependency edges become derivation
	links. The full provenance graph includes all \(evidence.graph_summary.total_resources) resources plus the
	generating `prov:Activity` and `prov:Agent`.

	### Graph Self-Description / VoID (computed)

	The `#VoIDDataset` pattern produces a VoID dataset description — the graph's
	machine-readable "about" page:

	```json
	\(_json.void)
	```

	\(evidence.void_description["void:entities"]) entities, \(evidence.void_description["void:triples"]) triples, \(evidence.void_description["void:classes"]) classes. Class partitions show
	how many resources belong to each `@type`. This is standard VoID — any LOD
	catalog or SPARQL endpoint description consumer can read it.

	### Type Ontology / RDFS+OWL (computed)

	The `#OWLOntology` pattern extracts the implicit ontology from the graph's
	type system. Each `@type` becomes an `rdfs:Class`; dependency edges become
	an `owl:ObjectProperty`:

	```json
	\(_json.owl)
	```

	\(evidence.owl_ontology["@graph"][0]["dcterms:title"]) — the graph's type vocabulary as a formal
	OWL ontology. Loadable in Protégé, validatable by OWL reasoners.

	### Type Vocabulary / SKOS (computed)

	The `#SKOSTaxonomy` pattern projects graph types as a SKOS ConceptScheme
	with broader/narrower hierarchy:

	```json
	\(_json.skos_taxonomy)
	```

	Each `@type` becomes a `skos:Concept` with `skos:broader` linking to
	parent categories. Types that co-occur on resources are linked via
	`skos:related`. The scheme is navigable by any SKOS-aware vocabulary
	browser.

	### Activity Stream (computed)

	The `#ActivityStream` pattern models graph construction as an Activity
	Streams 2.0 `OrderedCollection`:

	```json
	\(_json.activity_stream)
	```

	Each resource creation is a `Create` activity ordered by topological
	depth. Layer 0 resources (no dependencies) are created first. Dependency
	edges appear as `context` links.

	### Validation Credential / VC 2.0 (computed)

	The `#ValidationCredential` pattern wraps the SHACL validation result
	in a W3C Verifiable Credential:

	```json
	\(_json.verifiable_credential)
	```

	The credential attests that the graph passed compliance validation.
	The `credentialSubject` embeds the full `sh:ValidationReport`. This
	is the VC data model only — cryptographic proof requires an external
	issuer.

	### Spec Coverage

	\(evidence.spec_counts.implemented) specifications implemented,
	\(evidence.spec_counts.downstream) downstream (in the infrastructure-specific
	extension). Adding a projection is adding a file, not modifying a framework.

	**Implemented** (\(evidence.spec_counts.implemented)):

	| W3C Specification | CUE Produces |
	|-------------------|--------------|
	\(strings.Join(_spec_rows, "\n"))

	**Downstream** (\(evidence.spec_counts.downstream)):

	| W3C Specification | CUE Produces |
	|-------------------|--------------|
	\(strings.Join(_downstream_rows, "\n"))

	## Key Mechanisms

	### Transitive Closure via Unification

	```cue
	_ancestors: {
	    [_]: true
	    if _hasDeps {
	        for d, _ in _deps {
	            (d): true
	            resources[d]._ancestors
	        }
	    }
	}
	```

	Six lines. CUE resolves the fixpoint — the struct expands until merging
	produces no new keys, then stops. No explicit loop, no recursion depth
	tracking. This is the same mechanism as SPARQL property paths, but
	resolved statically.

	### Type Overlap as Dispatch

	```cue
	for tname, _ in provider.types
	if resource["@type"][tname] != _|_ {tname}
	```

	A resource with `{Dataset: true, Governance: true}` matches a data
	repository (serves Dataset) AND an ethics board (serves Governance)
	simultaneously. Set intersection, not registration. This is the CUE
	equivalent of SPARQL `?resource a ?type` pattern matching.

	### Constraints as Values

	CUE constraints live in the same package as the computation:

	```cue
	sh:conforms: true   // unification — false is ⊥
	```

	If a compliance check produces `sh:conforms: false`, unification with
	`true` is bottom (`_|_`). `cue vet` fails. No assertion framework —
	the language IS the constraint solver. SHACL validation becomes a type
	error.

	## Multi-Domain Validation

	The same patterns have been validated across four independent domains:

	| Domain | Resources | Patterns Used |
	|--------|-----------|---------------|
	| Research data mgmt | 5 resources, 3 types | Provenance, embargo, scheduling |
	| IT infrastructure | 30 nodes, 29 providers | Full stack (654 CLI commands) |
	| University curricula | 12 CS courses | Critical path, compliance, charter |
	| Construction PM | 18 work packages | 5 DAG gates, CMHC retrofit phases |

	Same `#Graph`, same `#CriticalPath`, same `#ComplianceCheck`. The domain is
	data; the patterns are generic.

	## Limitations

	- **Closed-world only.** All resources and constraints must be declared
	  upfront. Not a replacement for open-world RDF federation.
	- **DAGs only.** No cycles. Dependency graphs are directed acyclic by
	  definition in our target domains.
	- **Performance ceiling.** CUE's recursive struct references don't memoize.
	  For graphs exceeding ~40 nodes, pre-compute transitive closure externally
	  (solved: 95s to 33ms for a 40-node project charter).
	- **Not a general RDF toolkit.** This approach targets constrained domains
	  where schema control is a given.

	## Relevance to W3C Community Groups

	- **KG-Construct:** CUE as a declarative KG construction language —
	  graph building, SHACL validation, and RDF serialization in one
	  compile-time evaluation. No mapping language or runtime pipeline.
	- **Context Graphs:** Struct-as-set `@type` as multi-context resource
	  identity — one resource participates in data governance, provenance,
	  scheduling, and semantic web contexts simultaneously via set
	  intersection.
	- **PM-KR:** Charter pattern as compile-time project completion —
	  gap analysis, critical path, and EARL test plans from constraint
	  satisfaction. Project management as type checking.
	- **Dataspaces:** `.kb/` convention and ODRL/DCAT projections as
	  lightweight dataspace primitives with structural governance.
	  Each knowledge base entry validates against typed schemas at
	  evaluation time.

	## References

	- [github.com/quicue/apercue](https://github.com/quicue/apercue)
	  — Generic reference implementation (Apache 2.0)
	- [github.com/quicue/quicue.ca](https://github.com/quicue/quicue.ca)
	  — Infrastructure-specific extension
	- [demo.quicue.ca](https://demo.quicue.ca) — Interactive D3 explorer
	- [api.quicue.ca](https://api.quicue.ca) — Static API (727 pre-computed JSON files)
	- [docs.quicue.ca](https://docs.quicue.ca) — Module documentation
	"""
