# Compile-Time Linked Data: Full W3C Closure From a Single CUE Value

**Use Case Report for W3C Community Groups**

---

## Abstract

[CUE](https://cuelang.org)'s lattice-based unification simultaneously performs
SPARQL-class graph pattern matching and SHACL constraint validation at compile
time. A single typed dependency graph produces 17 W3C
specification outputs — including JSON-LD, SHACL, SKOS, OWL-Time, PROV-O, ODRL,
and Verifiable Credentials — without runtime processors, triplestores, or
pipelines. A 14th (Hydra) is implemented downstream.

This report documents the implementation, provides computed evidence from a live
example graph, and identifies relevance to four W3C Community Groups.

**All evidence below is computed, not hand-written.** Each JSON block is
generated by `cue export ./w3c/ -e evidence.<field>`. Reproduce from source:
[github.com/quicue/apercue](https://github.com/quicue/apercue).

## Problem Statement

The semantic web stack traditionally requires five or more runtime components:
an RDF store, a SPARQL query engine, a SHACL processor, a serializer, and a
query planner. Each introduces its own execution model, failure modes, and
infrastructure requirements. Schema drift between layers is common.

For constrained domains — research data management, project plans, infrastructure
topology, academic curricula — this operational complexity is disproportionate
to the problem. These domains share a common structure: typed resources with directed
acyclic dependency edges. They need standards-compliant output, not the full
semantic web runtime.

## Approach

[apercue.ca](https://github.com/quicue/apercue) implements a constraint-based
alternative using CUE, a configuration language with lattice-theoretic type
semantics. Resources declare two things: what they are (`@type`, a
struct-as-set) and what they need (`depends_on`, also a struct-as-set):

```cue
"analysis-code": {
    name:       "analysis-code"
    "@type":    {Process: true}
    depends_on: {"sensor-dataset": true}
}
```

Everything else — topology, impact analysis, compliance, scheduling, and every
W3C output — is a projection of this single value.
`cue export -e <expression>` produces the target format.

## Implementation Evidence

The inline example graph defines a 5-node research publication pipeline:
ethics approval, sensor dataset, analysis code, draft paper, and peer review.
This domain was chosen because W3C specifications map to their intended
purposes: Dublin Core for publication metadata, PROV-O for dataset provenance,
ODRL for data embargo policies, and OWL-Time for submission deadlines. This is
the same `#Graph` pattern used in production deployments with 30+ nodes.

### JSON-LD Context

All evidence blocks share this `@context`, which maps resource fields to
standard W3C vocabularies:

```json
{
    "@context": {
        "@base": "urn:resource:",
        "dcterms": "http://purl.org/dc/terms/",
        "prov": "http://www.w3.org/ns/prov#",
        "dcat": "http://www.w3.org/ns/dcat#",
        "sh": "http://www.w3.org/ns/shacl#",
        "skos": "http://www.w3.org/2004/02/skos/core#",
        "schema": "https://schema.org/",
        "time": "http://www.w3.org/2006/time#",
        "earl": "http://www.w3.org/ns/earl#",
        "odrl": "http://www.w3.org/ns/odrl/2/",
        "org": "http://www.w3.org/ns/org#",
        "cred": "https://www.w3.org/2018/credentials#",
        "as": "https://www.w3.org/ns/activitystreams#",
        "apercue": "https://apercue.ca/vocab#",
        "charter": "https://apercue.ca/charter#",
        "name": "dcterms:title",
        "description": "dcterms:description",
        "depends_on": {
            "@id": "dcterms:requires",
            "@type": "@id"
        },
        "status": {
            "@id": "schema:actionStatus",
            "@type": "@id"
        },
        "tags": {
            "@id": "dcterms:subject",
            "@container": "@set"
        }
    }
}
```

This context is not a configuration file — it is a CUE value computed from
the vocabulary registry. Every resource exported through this context produces
valid JSON-LD 1.1.

### SHACL Validation (computed)

A compliance rule requires that publications have upstream dependencies
(cannot exist without supporting data). The `#ComplianceCheck` pattern
produces a standard `sh:ValidationReport`:

```json
{
    "@type": "sh:ValidationReport",
    "sh:conforms": true,
    "sh:result": []
}
```

`sh:conforms: true` — all compliance rules pass. This is produced at CUE
evaluation time. No separate SHACL processor runs.

### Critical Path / OWL-Time (computed)

The `#CriticalPath` pattern computes forward/backward passes and identifies
the critical sequence:

```json
[
    {
        "resource": "ethics-approval",
        "start": 0,
        "finish": 60,
        "duration": 60
    },
    {
        "resource": "sensor-dataset",
        "start": 60,
        "finish": 150,
        "duration": 90
    },
    {
        "resource": "analysis-code",
        "start": 150,
        "finish": 195,
        "duration": 45
    },
    {
        "resource": "draft-paper",
        "start": 195,
        "finish": 225,
        "duration": 30
    },
    {
        "resource": "peer-review",
        "start": 225,
        "finish": 285,
        "duration": 60
    }
]
```

5-node critical path, 285-day total
duration. The same data produces standard OWL-Time `time:Interval` entries:

```json
{
    "@type": "time:Interval",
    "@id": "urn:resource:analysis-code",
    "dcterms:title": "analysis-code",
    "time:hasBeginning": {
        "@type": "time:Instant",
        "time:inXSDDecimal": 150
    },
    "time:hasEnd": {
        "@type": "time:Instant",
        "time:inXSDDecimal": 195
    },
    "time:hasDuration": {
        "@type": "time:Duration",
        "time:numericDuration": 45,
        "time:unitType": {
            "@id": "time:unitDay"
        }
    },
    "apercue:slack": 0,
    "apercue:isCritical": true
}
```

Each resource becomes a `time:Interval` with `time:hasBeginning`,
`time:hasEnd`, and `time:hasDuration`. Slack and criticality are extensions
in the `apercue:` namespace.

### Access Policy / ODRL (computed)

The `#ODRLPolicy` pattern projects dependency-graph resources into an ODRL
policy set:

```json
{
    "@type": "odrl:Set",
    "odrl:uid": "apercue:graph-policy",
    "odrl:permission": [
        {
            "odrl:action": {
                "@id": "odrl:read"
            }
        },
        {
            "odrl:action": {
                "@id": "odrl:execute"
            },
            "odrl:assignee": {
                "@id": "apercue:operator"
            }
        }
    ],
    "odrl:prohibition": []
}
```

Permissions and prohibitions are typed by the same `@type` set that drives
graph construction. Adding a policy is adding a CUE file, not configuring
middleware.

### Provenance / PROV-O (computed)

The `#ProvenanceTrace` pattern maps dependency edges to `prov:wasDerivedFrom`
relations:

```json
{
    "@type": "prov:Entity",
    "@id": "urn:resource:analysis-code",
    "dcterms:title": "analysis-code",
    "prov:wasAttributedTo": {
        "@id": "apercue:graph-engine"
    },
    "prov:wasDerivedFrom": [
        {
            "@id": "urn:resource:sensor-dataset"
        }
    ],
    "prov:wasGeneratedBy": {
        "@id": "apercue:graph-construction"
    }
}
```

Every resource becomes a `prov:Entity`. Dependency edges become derivation
links. The full provenance graph includes all 5 resources plus the
generating `prov:Activity` and `prov:Agent`.

### Spec Coverage

17 specifications implemented,
1 downstream (in the infrastructure-specific
extension). Adding a projection is adding a file, not modifying a framework.

**Implemented** (13):

| W3C Specification | CUE Produces |
|-------------------|--------------|
| JSON-LD 1.1 | @context, @type, @id on all resources |
| SHACL | sh:ValidationReport from compliance checks and gap analysis |
| SKOS | skos:ConceptScheme from type vocabularies and lifecycle phases |
| EARL | earl:Assertion from smoke test plans |
| OWL-Time | time:Interval from critical path scheduling |
| Dublin Core | dcterms:title, dcterms:description, dcterms:requires on all resources |
| PROV-O | prov:Entity + prov:wasDerivedFrom from dependency edges |
| schema.org | schema:additionalType annotations via configurable type mapping |
| ODRL 2.2 | odrl:Set policies with permissions/prohibitions by resource type |
| Activity Streams 2.0 | as:OrderedCollection of Create activities from topology layers |
| Verifiable Credentials 2.0 | VerifiableCredential wrapping SHACL validation attestation |
| W3C Org | org:Organization with type-based OrganizationalUnits |
| DCAT 3 | dcat:Catalog with dcat:Dataset per resource, dcat:theme from @type |

**Downstream** (1):

| W3C Specification | CUE Produces |
|-------------------|--------------|
| Hydra Core | hydra:ApiDocumentation in quicue.ca operator dashboard |

## Key Mechanisms

### Transitive Closure via Unification

```cue
_ancestors: {
    [_]: true
    if _hasDeps {
        for d, _ in _deps {
            (d): true
            resources[d]._ancestors
        }
    }
}
```

Six lines. CUE resolves the fixpoint — the struct expands until merging
produces no new keys, then stops. No explicit loop, no recursion depth
tracking. This is the same mechanism as SPARQL property paths, but
resolved statically.

### Type Overlap as Dispatch

```cue
for tname, _ in provider.types
if resource["@type"][tname] != _|_ {tname}
```

A resource with `{Dataset: true, Governance: true}` matches a data
repository (serves Dataset) AND an ethics board (serves Governance)
simultaneously. Set intersection, not registration. This is the CUE
equivalent of SPARQL `?resource a ?type` pattern matching.

### Constraints as Values

CUE constraints live in the same package as the computation:

```cue
sh:conforms: true   // unification — false is ⊥
```

If a compliance check produces `sh:conforms: false`, unification with
`true` is bottom (`_|_`). `cue vet` fails. No assertion framework —
the language IS the constraint solver. SHACL validation becomes a type
error.

## Multi-Domain Validation

The same patterns have been validated across four independent domains:

| Domain | Resources | Patterns Used |
|--------|-----------|---------------|
| Research data mgmt | 5 resources, 3 types | Provenance, embargo, scheduling |
| IT infrastructure | 30 nodes, 29 providers | Full stack (654 CLI commands) |
| University curricula | 12 CS courses | Critical path, compliance, charter |
| Construction PM | 18 work packages | 5 DAG gates, CMHC retrofit phases |

Same `#Graph`, same `#CriticalPath`, same `#ComplianceCheck`. The domain is
data; the patterns are generic.

## Limitations

- **Closed-world only.** All resources and constraints must be declared
  upfront. Not a replacement for open-world RDF federation.
- **DAGs only.** No cycles. Dependency graphs are directed acyclic by
  definition in our target domains.
- **Performance ceiling.** CUE's recursive struct references don't memoize.
  For graphs exceeding ~40 nodes, pre-compute transitive closure externally
  (solved: 95s to 33ms for a 40-node project charter).
- **Not a general RDF toolkit.** This approach targets constrained domains
  where schema control is a given.

## Relevance to W3C Community Groups

- **KG-Construct:** CUE as a declarative KG construction language —
  graph building, SHACL validation, and RDF serialization in one
  compile-time evaluation. No mapping language or runtime pipeline.
- **Context Graphs:** Struct-as-set `@type` as multi-context resource
  identity — one resource participates in data governance, provenance,
  scheduling, and semantic web contexts simultaneously via set
  intersection.
- **PM-KR:** Charter pattern as compile-time project completion —
  gap analysis, critical path, and EARL test plans from constraint
  satisfaction. Project management as type checking.
- **Dataspaces:** `.kb/` convention and ODRL/DCAT projections as
  lightweight dataspace primitives with structural governance.
  Each knowledge base entry validates against typed schemas at
  evaluation time.

## References

- [github.com/quicue/apercue](https://github.com/quicue/apercue)
  — Generic reference implementation (Apache 2.0)
- [github.com/quicue/quicue.ca](https://github.com/quicue/quicue.ca)
  — Infrastructure-specific extension
- [demo.quicue.ca](https://demo.quicue.ca) — Interactive D3 explorer
- [api.quicue.ca](https://api.quicue.ca) — Static API (727 pre-computed JSON files)
- [docs.quicue.ca](https://docs.quicue.ca) — Module documentation
