# Compile-Time Linked Data: Full W3C Closure From a Single CUE Value

**Use Case Report for W3C Community Groups**

## Abstract

CUE's lattice-based unification simultaneously performs SPARQL-class
graph pattern matching and SHACL constraint validation at compile time.
A single typed dependency graph produces 14
W3C specification outputs — including JSON-LD, SHACL, SKOS, OWL-Time,
PROV-O, ODRL, and Verifiable Credentials — without runtime processors,
triplestores, or pipelines. This report documents the implementation,
provides computed evidence, and identifies relevance to four W3C
Community Groups.

## Problem Statement

The semantic web stack traditionally requires five or more runtime
components: an RDF store, a SPARQL query engine, a SHACL processor,
a serializer, and a query planner. Each introduces its own execution
model, failure modes, and infrastructure requirements. Schema drift
between layers is common. For constrained domains — infrastructure
topology, project plans, supply chains, academic curricula — this
operational complexity is disproportionate to the problem.

## Approach

[apercue.ca](https://github.com/quicue/apercue) implements a
constraint-based alternative using [CUE](https://cuelang.org), a
configuration language with lattice-theoretic type semantics.

Resources declare two things: what they are (`@type`, a struct-as-set)
and what they need (`depends_on`, also a struct-as-set):

```cue
"cpu-chip": {
    name: "cpu-chip"
    "@type": {Component: true}
    depends_on: {"silicon-wafer": true}
}
```

Everything else — topology, impact analysis, compliance, scheduling,
and every W3C output — is a projection of this single value.
`cue export -e <expression>` produces the target format.

## Implementation Evidence

The following evidence is **computed, not hand-written**. Each JSON
block below is generated by `cue export ./w3c/ -e evidence.<field>`.
The inline graph (5 supply-chain nodes) uses the same patterns as
production deployments.

### Spec Coverage

12 specs implemented,
2 downstream,
14 total. Adding a projection is adding
a file, not modifying a framework.

### SHACL Validation (computed)

```json
{
    "@context": {
        "@base": "urn:resource:",
        "dcterms": "http://purl.org/dc/terms/",
        "prov": "http://www.w3.org/ns/prov#",
        "dcat": "http://www.w3.org/ns/dcat#",
        "sh": "http://www.w3.org/ns/shacl#",
        "skos": "http://www.w3.org/2004/02/skos/core#",
        "schema": "https://schema.org/",
        "time": "http://www.w3.org/2006/time#",
        "earl": "http://www.w3.org/ns/earl#",
        "odrl": "http://www.w3.org/ns/odrl/2/",
        "org": "http://www.w3.org/ns/org#",
        "cred": "https://www.w3.org/2018/credentials#",
        "as": "https://www.w3.org/ns/activitystreams#",
        "apercue": "https://apercue.ca/vocab#",
        "charter": "https://apercue.ca/charter#",
        "name": "dcterms:title",
        "description": "dcterms:description",
        "depends_on": {
            "@id": "dcterms:requires",
            "@type": "@id"
        },
        "status": {
            "@id": "schema:actionStatus",
            "@type": "@id"
        },
        "tags": {
            "@id": "dcterms:subject",
            "@container": "@set"
        }
    },
    "@type": "sh:ValidationReport",
    "sh:conforms": true,
    "sh:result": []
}
```

This `sh:ValidationReport` is produced at CUE evaluation time.
No separate SHACL processor. `sh:conforms: true` means all
compliance rules pass.

### Critical Path / OWL-Time (computed)

```json
[
    {
        "resource": "silicon-wafer",
        "start": 0,
        "finish": 14,
        "duration": 14
    },
    {
        "resource": "cpu-chip",
        "start": 14,
        "finish": 44,
        "duration": 30
    },
    {
        "resource": "motherboard",
        "start": 44,
        "finish": 51,
        "duration": 7
    },
    {
        "resource": "laptop",
        "start": 51,
        "finish": 53,
        "duration": 2
    }
]
```

Four-node critical path, 53-day total duration. Each entry is a
`time:Interval` with `time:hasBeginning`, `time:hasEnd`, and
`time:hasDuration` — standard OWL-Time.

### Additional Projections

The same graph also produces ODRL access policies (`odrl:Set`),
PROV-O provenance traces (`prov:Entity`), Activity Streams change
feeds (`as:OrderedCollection`), and Verifiable Credentials wrapping
SHACL attestation. Each is one more `cue export -e <expression>`.

## Key Mechanisms

### Transitive Closure via Unification

```cue
_ancestors: {
    [_]: true
    if _hasDeps {
        for d, _ in _deps {
            (d): true
            resources[d]._ancestors
        }
    }
}
```

Six lines. CUE resolves the fixpoint — the struct expands until
merging produces no new keys, then stops. No explicit loop, no
recursion depth tracking.

### Type Overlap as Dispatch

```cue
for tname, _ in provider.types
if resource["@type"][tname] != _|_ {tname}
```

A resource with `{LXCContainer: true, DNSServer: true}` matches
Proxmox (serves LXCContainer) AND PowerDNS (serves DNSServer)
simultaneously. Set intersection, not registration.

### Constraints as Values

```cue
validate: valid: true
```

Same package as the computation. If the graph produces `valid: false`,
unification with `true` is bottom. `cue vet` fails. No assertion
framework — the language IS the constraint solver.

## Multi-Domain Validation

| Domain | Resources | Patterns Used |
|--------|-----------|---------------|
| IT infrastructure | 30 nodes, 29 providers | Full stack (654 CLI commands) |
| University curricula | 12 CS courses | Critical path, compliance, charter |
| Construction PM | 18 work packages | 5 DAG gates, CMHC retrofit phases |
| Supply chain | 14 parts, 5 tiers | BOM completeness, lead time CPM |

Same `#Graph`, same `#CriticalPath`, same `#ComplianceCheck`. The
domain is irrelevant — the patterns compute depth, ancestors, impact,
deployment order, and critical path identically.

## Limitations

- **Closed-world only.** All resources and constraints must be known
  upfront. Not a replacement for open-world RDF federation.
- **DAGs only.** No cycles. Dependency graphs are directed acyclic by
  definition in our domains.
- **Performance ceiling.** CUE's recursive struct references don't
  memoize. For graphs >20 nodes, pre-compute transitive closure in
  Python (solved: 95s → 33ms for 40-node self-charter).
- **Not a general RDF toolkit.** This approach targets constrained
  domains where schema control is a given.

## Relevance to W3C Community Groups

- **KG-Construct:** CUE as a declarative KG construction language —
  graph building, SHACL validation, and RDF serialization in one
  compile-time evaluation.
- **Context Graphs:** Struct-as-set `@type` as multi-context resource
  identity — one resource participates in infrastructure, compliance,
  scheduling, and semantic web contexts simultaneously.
- **PM-KR:** Charter pattern as compile-time project completion —
  gap analysis, critical path, and EARL test plans from constraint
  satisfaction.
- **Dataspaces:** `.kb/` convention and ODRL/DCAT projections as
  lightweight dataspace primitives with structural governance.

## References

- [github.com/quicue/apercue](https://github.com/quicue/apercue)
  — Generic reference implementation (Apache 2.0)
- [github.com/quicue/quicue.ca](https://github.com/quicue/quicue.ca)
  — Infrastructure-specific extension
- [demo.quicue.ca](https://demo.quicue.ca) — Interactive D3 explorer
- [api.quicue.ca](https://api.quicue.ca) — Static API (727 pre-computed JSON files)
- [docs.quicue.ca](https://docs.quicue.ca) — Module documentation
