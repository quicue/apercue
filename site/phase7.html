<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Phase 7: Wire the Stack — quicue.ca</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible+Mono:ital,wght@0,200..800;1,200..800&family=Atkinson+Hyperlegible+Next:ital,wght@0,200..800;1,200..800&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0a0e14;
  --bg-panel: #0f1319;
  --bg-hover: #151b24;
  --border: #1e2733;
  --border-bright: #2a3545;
  --text: #c5cdd8;
  --text-dim: #5c6978;
  --text-bright: #e8ecf1;
  --accent: #3ddc84;
  --accent-dim: rgba(61, 220, 132, 0.15);

  /* Phase palette — migration progression */
  --phase-1: #5b9cf6;  /* Interop Foundation — blue */
  --phase-2: #7b6cf6;  /* Apercue Exports — purple */
  --phase-3: #c084fc;  /* Quicue Imports — violet */
  --phase-4: #34d1bf;  /* Verify Chain — teal */
  --phase-5: #f0c040;  /* Finalize — gold */
  --phase-6: #f09070;  /* W3C Alignment — coral */

  --body: 'Atkinson Hyperlegible Next', sans-serif;
  --mono: 'Atkinson Hyperlegible Mono', monospace;

  /* Type indicators */
  --type-setup: #5b9cf6;
  --type-test: #34d1bf;
  --type-gate: #f0c040;
  --type-verification: #7b6cf6;
  --type-migration: #c084fc;
  --type-bugfix: #f09070;
  --type-cleanup: #e8b84d;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: var(--body);
  overflow: hidden;
  height: 100vh;
}

body::before {
  content: '';
  position: fixed;
  inset: 0;
  background-image:
    radial-gradient(circle at 20% 50%, rgba(91, 156, 246, 0.03) 0%, transparent 50%),
    radial-gradient(circle at 80% 30%, rgba(61, 220, 132, 0.03) 0%, transparent 50%),
    radial-gradient(circle, rgba(200, 200, 220, 0.02) 1px, transparent 1px);
  background-size: 100% 100%, 100% 100%, 24px 24px;
  pointer-events: none;
  z-index: 0;
}

.layout {
  display: grid;
  grid-template-columns: 280px 1fr;
  height: 100vh;
  position: relative;
  z-index: 1;
}

/* ── Sidebar ───────────────────────────────── */
.sidebar {
  background: var(--bg-panel);
  border-right: 1px solid var(--border);
  overflow-y: auto;
  scrollbar-width: thin;
  scrollbar-color: var(--border) var(--bg-panel);
}

.sidebar-header {
  padding: 20px;
  border-bottom: 1px solid var(--border);
}

.sidebar-title {
  font-family: var(--mono);
  font-size: 13px;
  font-weight: 600;
  color: var(--text-bright);
  letter-spacing: 0.02em;
}

.sidebar-subtitle {
  font-family: var(--mono);
  font-size: 10px;
  color: var(--text-dim);
  margin-top: 4px;
  letter-spacing: 0.05em;
  text-transform: uppercase;
}

.status-badge {
  display: inline-block;
  font-family: var(--mono);
  font-size: 10px;
  font-weight: 500;
  padding: 3px 8px;
  border-radius: 2px;
  margin-top: 8px;
  letter-spacing: 0.05em;
}

.status-badge.complete {
  color: var(--accent);
  background: var(--accent-dim);
  border: 1px solid rgba(61, 220, 132, 0.25);
}

.status-badge.incomplete {
  color: #f0c040;
  background: rgba(240, 192, 64, 0.15);
  border: 1px solid rgba(240, 192, 64, 0.25);
}

/* Progress bar */
.progress-bar {
  margin-top: 12px;
  height: 4px;
  background: var(--border);
  border-radius: 2px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: var(--accent);
  border-radius: 2px;
  transition: width 0.3s;
}

/* Metrics */
.metrics {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1px;
  background: var(--border);
  border-bottom: 1px solid var(--border);
}

.metric {
  background: var(--bg-panel);
  padding: 12px 16px;
  text-align: center;
}

.metric-value {
  font-family: var(--mono);
  font-size: 20px;
  font-weight: 600;
  color: var(--text-bright);
}

.metric-label {
  font-size: 10px;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  margin-top: 2px;
}

/* Gate timeline */
.section-label {
  font-family: var(--mono);
  font-size: 10px;
  font-weight: 500;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.1em;
  padding: 16px 20px 8px;
}

.gate-list {
  list-style: none;
  padding: 0 20px 16px;
}

.gate-item {
  position: relative;
  padding: 10px 0 10px 24px;
  border-left: 2px solid var(--border);
  margin-left: 6px;
  cursor: pointer;
  transition: background 0.15s;
}

.gate-item:hover { background: var(--bg-hover); margin: 0 -20px; padding-left: 44px; padding-right: 20px; }

.gate-item:last-child { border-left-color: transparent; }

.gate-item::before {
  content: '';
  position: absolute;
  left: -7px;
  top: 14px;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  border: 2px solid var(--border);
  background: var(--bg-panel);
  transition: all 0.2s;
}

.gate-item.satisfied::before {
  border-color: var(--accent);
  background: var(--accent);
  box-shadow: 0 0 8px rgba(61, 220, 132, 0.3);
}

.gate-item .gate-phase {
  font-family: var(--mono);
  font-size: 10px;
  color: var(--text-dim);
  letter-spacing: 0.05em;
}

.gate-item .gate-name {
  font-size: 13px;
  font-weight: 500;
  color: var(--text-bright);
  margin-top: 2px;
}

.gate-item .gate-desc {
  font-size: 11px;
  color: var(--text-dim);
  margin-top: 2px;
}

.gate-item .gate-count {
  font-family: var(--mono);
  font-size: 10px;
  color: var(--text-dim);
  margin-top: 4px;
}

/* Legend */
.legend {
  padding: 0 20px 20px;
}

.legend-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 6px;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  color: var(--text-dim);
}

.legend-swatch {
  width: 10px;
  height: 10px;
  border-radius: 2px;
  flex-shrink: 0;
}

.legend-swatch.done-indicator {
  border: 2px solid var(--accent);
  background: var(--accent);
  width: 8px;
  height: 8px;
}

.legend-swatch.pending-indicator {
  border: 2px dashed var(--text-dim);
  background: transparent;
  width: 8px;
  height: 8px;
  border-radius: 50%;
}

/* ── Graph area ────────────────────────────── */
.graph-container {
  position: relative;
  overflow: hidden;
}

.graph-container svg {
  width: 100%;
  height: 100%;
}

/* Phase lane labels */
.phase-label {
  font-family: var(--mono);
  font-size: 10px;
  fill: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.1em;
  opacity: 0.5;
}

.phase-divider {
  stroke: var(--border);
  stroke-dasharray: 4,4;
  opacity: 0.3;
}

/* Edges */
.edge {
  stroke: var(--border);
  stroke-width: 1;
  fill: none;
  opacity: 0.4;
  transition: opacity 0.2s, stroke 0.2s;
}

.edge.highlighted {
  stroke: var(--accent);
  stroke-width: 1.5;
  opacity: 0.8;
}

.edge.faded { opacity: 0.08; }

.edge.critical {
  stroke: var(--accent);
  stroke-width: 2;
  opacity: 0.7;
  stroke-dasharray: 6 3;
  animation: dash-flow 1.5s linear infinite;
}

@keyframes dash-flow {
  to { stroke-dashoffset: -18; }
}

.node.critical circle {
  filter: drop-shadow(0 0 6px var(--accent));
}

/* Nodes */
.node { cursor: pointer; }

.node circle {
  stroke-width: 2;
  transition: r 0.2s, stroke-width 0.2s;
}

.node.faded circle { opacity: 0.15; }
.node.faded text { opacity: 0.1; }
.node.pending circle { stroke-dasharray: 4 3; opacity: 0.5; }
.node.pending text { opacity: 0.4; }
.node.done circle { opacity: 1; }

.node text {
  font-family: var(--mono);
  font-size: 9px;
  fill: var(--text);
  text-anchor: middle;
  pointer-events: none;
  transition: opacity 0.2s;
}

.node:hover circle {
  stroke-width: 3;
  filter: drop-shadow(0 0 6px currentColor);
}

/* Tooltip */
.tooltip {
  position: absolute;
  background: var(--bg-panel);
  border: 1px solid var(--border-bright);
  border-radius: 4px;
  padding: 12px 16px;
  font-size: 12px;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.15s;
  max-width: 280px;
  z-index: 10;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
}

.tooltip.visible { opacity: 1; }

.tooltip-name {
  font-family: var(--mono);
  font-weight: 600;
  color: var(--text-bright);
  font-size: 13px;
}

.tooltip-type {
  font-family: var(--mono);
  font-size: 10px;
  margin-top: 4px;
}

.tooltip-type span {
  display: inline-block;
  padding: 1px 6px;
  border-radius: 2px;
  margin-right: 4px;
}

.tooltip-desc {
  color: var(--text-dim);
  margin-top: 6px;
  line-height: 1.5;
}

.tooltip-meta {
  font-family: var(--mono);
  font-size: 10px;
  color: var(--text-dim);
  margin-top: 6px;
  padding-top: 6px;
  border-top: 1px solid var(--border);
}

/* Nav links */
.nav-links {
  padding: 12px 20px;
  border-top: 1px solid var(--border);
  display: flex;
  gap: 16px;
}

.nav-links a {
  font-family: var(--mono);
  font-size: 11px;
  color: var(--text-dim);
  text-decoration: none;
  border-bottom: 1px solid transparent;
  transition: all 0.2s;
}

.nav-links a:hover {
  color: var(--accent);
  border-bottom-color: var(--accent);
}

/* Task list */
.task-list {
  list-style: none;
  padding: 0 20px 16px;
  max-height: 300px;
  overflow-y: auto;
  scrollbar-width: thin;
  scrollbar-color: var(--border) var(--bg-panel);
}

.task-item {
  padding: 6px 0;
  border-bottom: 1px solid var(--border);
  font-size: 11px;
  cursor: pointer;
  transition: background 0.15s;
}

.task-item:hover { background: var(--bg-hover); margin: 0 -20px; padding-left: 20px; padding-right: 20px; }

.task-item .task-name {
  font-family: var(--mono);
  font-size: 11px;
  color: var(--text-bright);
}

.task-item .task-status {
  font-family: var(--mono);
  font-size: 9px;
  padding: 1px 4px;
  border-radius: 2px;
  margin-left: 6px;
}

.task-item .task-status.done {
  color: var(--accent);
  background: var(--accent-dim);
}

.task-item .task-status.pending {
  color: var(--text-dim);
  background: rgba(92, 105, 120, 0.15);
}

.task-item .task-desc {
  color: var(--text-dim);
  font-size: 10px;
  margin-top: 2px;
  line-height: 1.4;
}

/* Arrowhead marker */
marker path { fill: var(--border); }
marker.highlighted path { fill: var(--accent); }
</style>
</head>
<body>
<div class="layout">

<!-- SIDEBAR -->
<aside class="sidebar">
  <div class="sidebar-header">
    <div class="sidebar-title">phase 7: wire the stack</div>
    <div class="sidebar-subtitle">apercue &rarr; quicue.ca migration</div>
    <div id="status-badge"></div>
    <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
  </div>

  <div class="metrics" id="metrics"></div>

  <div class="section-label">Phase Gates</div>
  <ul class="gate-list" id="gate-list"></ul>

  <div class="section-label">Types</div>
  <div class="legend" id="legend"></div>

  <div class="section-label">Status</div>
  <div class="legend" id="status-legend"></div>

  <div class="section-label">Tasks</div>
  <ul class="task-list" id="task-list"></ul>

  <div class="nav-links">
    <a href="phase7-spec.html">W3C Spec</a>
    <a href="charter.html">Apercue Charter</a>
    <a href="explorer.html">Ecosystem</a>
  </div>
</aside>

<!-- GRAPH -->
<div class="graph-container" id="graph-area">
  <svg id="graph-svg"></svg>
  <div class="tooltip" id="tooltip"></div>
</div>

</div>

<script>
const DATA_URL = 'data/phase7-charter.json';

const PHASE_COLORS = {
  1: '#5b9cf6', 2: '#7b6cf6', 3: '#c084fc',
  4: '#34d1bf', 5: '#f0c040', 6: '#f09070'
};

const PHASE_NAMES = {
  1: 'Interop Foundation', 2: 'Apercue Exports', 3: 'Quicue Imports',
  4: 'Verify Chain', 5: 'Finalize', 6: 'W3C Alignment'
};

const TYPE_COLORS = {
  Setup: '#5b9cf6', Test: '#34d1bf', Gate: '#f0c040',
  Verification: '#7b6cf6', Migration: '#c084fc',
  Bugfix: '#f09070', Cleanup: '#e8b84d'
};

// Derive phase from depth — maps to the 5-phase gate structure
function derivePhase(depth) {
  if (depth <= 2) return 1;
  if (depth <= 3) return 2;
  if (depth <= 7) return 3;
  if (depth <= 12) return 4;
  if (depth <= 14) return 5;
  return 6;
}

function primaryType(types) {
  const order = ['Migration','Verification','Gate','Test','Setup','Bugfix','Cleanup'];
  for (const t of order) if (types.includes(t)) return t;
  return types[0] || 'Setup';
}

async function init() {
  let data;
  try {
    data = await fetch(DATA_URL).then(r => r.json());
  } catch(e) {
    console.error('Failed to load data:', e);
    return;
  }

  // Normalize nodes: extract type keys, assign id/phase, derive gate
  data.nodes.forEach(n => {
    n.id = n.name;
    n.types = Object.keys(n.types);
    n.phase = derivePhase(n.depth);
  });

  // Normalize edges: from/to → source/target
  data.edges.forEach(e => {
    e.source = e.from;
    e.target = e.to;
  });

  // Build lookup
  window.nodeMap = {};
  data.nodes.forEach(n => { nodeMap[n.id] = n; });

  // Build critical path set
  window.criticalSet = new Set();
  if (data.scheduling && data.scheduling.critical_tasks) {
    data.scheduling.critical_tasks.forEach(t => criticalSet.add(t));
  }

  // Build gate → resources mapping (from missing keys)
  window.gateResources = {};
  for (const [gname, g] of Object.entries(data.gates)) {
    gateResources[gname] = Object.keys(g.missing || {});
  }

  renderSidebar(data);
  renderGraph(data);
}

function renderSidebar(data) {
  const summary = data.summary;

  // Status badge
  const badge = document.getElementById('status-badge');
  badge.innerHTML = `<span class="status-badge ${summary.complete ? 'complete' : 'incomplete'}">${
    summary.complete ? 'ALL GATES SATISFIED' : `NEXT: ${summary.next_gate}`
  }</span>`;

  // Progress bar
  const pct = summary.deliverables > 0 ? (summary.completed / summary.deliverables * 100) : 0;
  document.getElementById('progress-fill').style.width = pct + '%';

  // Metrics
  const m = document.getElementById('metrics');
  const doneCount = data.nodes.filter(n => n.status === 'done').length;
  const totalGates = Object.keys(data.gates).length;
  const satisfiedGates = Object.values(data.gates).filter(g => g.satisfied).length;
  const metrics = [
    [`${doneCount}/${summary.deliverables}`, 'Done'],
    [data.edges.length, 'Edges'],
    [`${satisfiedGates}/${totalGates}`, 'Gates'],
    [summary.critical_path_length, 'CPM Length'],
  ];
  m.innerHTML = metrics.map(([v,l]) =>
    `<div class="metric"><div class="metric-value">${v}</div><div class="metric-label">${l}</div></div>`
  ).join('');

  // Gate timeline
  const gl = document.getElementById('gate-list');
  const sortedGates = Object.entries(data.gates).sort((a,b) => a[1].phase - b[1].phase);
  gl.innerHTML = sortedGates.map(([name, gate]) => {
    const color = PHASE_COLORS[gate.phase] || '#5b9cf6';
    const missingKeys = Object.keys(gate.missing || {});
    const totalForGate = missingKeys.length + (gate.satisfied ? 0 : 0);
    return `<li class="gate-item ${gate.satisfied ? 'satisfied' : ''}" data-gate="${name}">
      <div class="gate-phase" style="color: ${color}">Phase ${gate.phase} &mdash; ${PHASE_NAMES[gate.phase] || ''}</div>
      <div class="gate-name">${name}</div>
      <div class="gate-count">${gate.satisfied ? 'satisfied' : `${missingKeys.length} remaining`}</div>
    </li>`;
  }).join('');

  // Gate hover → highlight resources
  gl.querySelectorAll('.gate-item').forEach(el => {
    el.addEventListener('mouseenter', () => {
      const gateName = el.dataset.gate;
      const resources = new Set(gateResources[gateName] || []);
      highlightNodes(resources);
    });
    el.addEventListener('mouseleave', clearHighlight);
  });

  // Task list
  const tl = document.getElementById('task-list');
  const sortedNodes = [...data.nodes].sort((a,b) => a.depth - b.depth);
  tl.innerHTML = sortedNodes.map(n => {
    const statusCls = n.status === 'done' ? 'done' : 'pending';
    const statusLabel = n.status === 'done' ? 'DONE' : 'PENDING';
    return `<li class="task-item" data-task="${n.name}">
      <div><span class="task-name">${n.name}</span>
      <span class="task-status ${statusCls}">${statusLabel}</span></div>
      <div class="task-desc">${n.description}</div>
    </li>`;
  }).join('');

  tl.querySelectorAll('.task-item').forEach(el => {
    el.addEventListener('mouseenter', () => {
      highlightNodes(new Set([el.dataset.task]));
    });
    el.addEventListener('mouseleave', clearHighlight);
  });

  // Legend — types
  const lg = document.getElementById('legend');
  lg.innerHTML = '<div class="legend-grid">' +
    Object.entries(TYPE_COLORS).map(([t, c]) =>
      `<div class="legend-item"><span class="legend-swatch" style="background:${c}"></span>${t}</div>`
    ).join('') + '</div>';

  // Legend — status
  const sl = document.getElementById('status-legend');
  sl.innerHTML = '<div class="legend-grid">' +
    '<div class="legend-item"><span class="legend-swatch done-indicator"></span>Done</div>' +
    '<div class="legend-item"><span class="legend-swatch pending-indicator"></span>Pending</div>' +
    '</div>';
}

let nodeElements, edgeElements;

function highlightNodes(nameSet) {
  if (!nodeElements) return;
  nodeElements.classed('faded', d => !nameSet.has(d.id));
  edgeElements.classed('faded', d => !nameSet.has(d.source.id || d.source) && !nameSet.has(d.target.id || d.target));
  edgeElements.classed('highlighted', d => nameSet.has(d.source.id || d.source) && nameSet.has(d.target.id || d.target));
}

function clearHighlight() {
  if (!nodeElements) return;
  nodeElements.classed('faded', false);
  edgeElements.classed('faded', false).classed('highlighted', false);
}

function renderGraph(data) {
  const container = document.getElementById('graph-area');
  const svg = d3.select('#graph-svg');
  const width = container.clientWidth;
  const height = container.clientHeight;

  svg.attr('viewBox', [0, 0, width, height]);

  // Arrow marker
  svg.append('defs').append('marker')
    .attr('id', 'arrow')
    .attr('viewBox', '0 -4 8 8')
    .attr('refX', 16).attr('refY', 0)
    .attr('markerWidth', 6).attr('markerHeight', 6)
    .attr('orient', 'auto')
    .append('path').attr('d', 'M0,-3L7,0L0,3').attr('fill', '#2a3545');

  const g = svg.append('g');

  // Zoom
  const zoom = d3.zoom()
    .scaleExtent([0.3, 4])
    .on('zoom', e => g.attr('transform', e.transform));
  svg.call(zoom);

  // Deterministic layered layout — depth on Y axis, siblings spread on X
  const maxDepth = Math.max(...data.nodes.map(n => n.depth));
  const marginY = 80;
  const layerH = (height - marginY * 2) / Math.max(maxDepth, 1);

  // Group by depth for layout
  const depthGroups = {};
  data.nodes.forEach(n => {
    if (!depthGroups[n.depth]) depthGroups[n.depth] = [];
    depthGroups[n.depth].push(n);
  });

  // Phase lane backgrounds
  const phaseDepthRanges = {};
  data.nodes.forEach(n => {
    if (!phaseDepthRanges[n.phase]) phaseDepthRanges[n.phase] = [Infinity, -Infinity];
    phaseDepthRanges[n.phase][0] = Math.min(phaseDepthRanges[n.phase][0], n.depth);
    phaseDepthRanges[n.phase][1] = Math.max(phaseDepthRanges[n.phase][1], n.depth);
  });

  Object.entries(phaseDepthRanges).forEach(([phase, [minD, maxD]]) => {
    const y1 = marginY + minD * layerH - layerH * 0.4;
    const y2 = marginY + maxD * layerH + layerH * 0.4;
    const color = PHASE_COLORS[phase] || '#5b9cf6';

    g.append('rect')
      .attr('x', 20).attr('y', y1)
      .attr('width', width - 40).attr('height', y2 - y1)
      .attr('rx', 4)
      .attr('fill', color).attr('opacity', 0.02);

    g.append('text')
      .attr('class', 'phase-label')
      .attr('x', 32).attr('y', y1 + 14)
      .attr('fill', color)
      .text(`Phase ${phase} — ${PHASE_NAMES[phase] || ''}`);
  });

  // Deterministic layout — fixed positions, no simulation jitter
  data.nodes.forEach(n => {
    const group = depthGroups[n.depth];
    const idx = group.indexOf(n);
    const count = group.length;
    const spacing = Math.min((width - 80) / (count + 1), 140);
    const startX = (width - (count - 1) * spacing) / 2;
    n.x = startX + idx * spacing;
    n.y = marginY + n.depth * layerH;
  });

  // Resolve edge endpoints to node objects
  const nodeById = {};
  data.nodes.forEach(n => { nodeById[n.id] = n; });
  data.edges.forEach(e => {
    if (typeof e.source === 'string') e.source = nodeById[e.source];
    if (typeof e.target === 'string') e.target = nodeById[e.target];
  });

  // Edges — Bezier curves following dependency flow
  edgeElements = g.append('g')
    .selectAll('path')
    .data(data.edges)
    .join('path')
    .attr('class', d => {
      const s = d.source.id || d.source;
      const t = d.target.id || d.target;
      return 'edge' + (criticalSet.has(s) && criticalSet.has(t) ? ' critical' : '');
    })
    .attr('marker-end', 'url(#arrow)')
    .attr('d', d => {
      const dx = d.target.x - d.source.x;
      const dy = d.target.y - d.source.y;
      const cx = d.source.x + dx * 0.5;
      const cy1 = d.source.y + dy * 0.3;
      const cy2 = d.source.y + dy * 0.7;
      return `M${d.source.x},${d.source.y} C${cx},${cy1} ${cx},${cy2} ${d.target.x},${d.target.y}`;
    });

  // Nodes
  nodeElements = g.append('g')
    .selectAll('g')
    .data(data.nodes)
    .join('g')
    .attr('class', d => {
      let cls = 'node';
      if (d.status === 'pending') cls += ' pending';
      if (d.status === 'done') cls += ' done';
      if (criticalSet.has(d.id)) cls += ' critical';
      return cls;
    });

  nodeElements.append('circle')
    .attr('r', d => d.depth === 0 ? 14 : d.types.length > 1 ? 11 : 9)
    .attr('fill', d => {
      const color = PHASE_COLORS[d.phase] || '#5b9cf6';
      return d.status === 'pending' ? 'transparent' : color + '20';
    })
    .attr('stroke', d => TYPE_COLORS[primaryType(d.types)] || '#5b9cf6')
    .style('color', d => TYPE_COLORS[primaryType(d.types)] || '#5b9cf6');

  nodeElements.append('text')
    .attr('dy', d => (d.depth === 0 ? 14 : d.types.length > 1 ? 11 : 9) + 14)
    .text(d => d.name.length > 18 ? d.name.substring(0, 16) + '\u2026' : d.name);

  // Tooltip
  const tooltip = document.getElementById('tooltip');
  nodeElements.on('mouseenter', (e, d) => {
    const typeSpans = d.types.map(t => {
      const c = TYPE_COLORS[t] || '#5b9cf6';
      return `<span style="background:${c}20;color:${c};border:1px solid ${c}40">${t}</span>`;
    }).join('');

    const statusLabel = d.status === 'done'
      ? '<span style="color:var(--accent)">DONE</span>'
      : '<span style="color:var(--text-dim)">PENDING</span>';

    const slackLabel = d.slack === 0
      ? '<span style="color:var(--accent)">CRITICAL PATH</span>'
      : `Slack ${d.slack}`;

    tooltip.innerHTML = `
      <div class="tooltip-name">${d.name}</div>
      <div class="tooltip-type">${typeSpans}</div>
      <div class="tooltip-desc">${d.description}</div>
      <div class="tooltip-meta">
        Phase ${d.phase} &middot; Depth ${d.depth} &middot; ${statusLabel}
      </div>
      <div class="tooltip-meta">
        ES ${d.earliest} &middot; LS ${d.latest} &middot; ${slackLabel}
      </div>`;
    tooltip.classList.add('visible');

    // Highlight connected
    const connected = new Set([d.id]);
    data.edges.forEach(edge => {
      const s = edge.source.id || edge.source;
      const t = edge.target.id || edge.target;
      if (s === d.id) connected.add(t);
      if (t === d.id) connected.add(s);
    });
    highlightNodes(connected);
  })
  .on('mousemove', e => {
    tooltip.style.left = (e.clientX - 280 + 16) + 'px';
    tooltip.style.top = (e.clientY - 10) + 'px';
  })
  .on('mouseleave', () => {
    tooltip.classList.remove('visible');
    clearHighlight();
  });

  // Position nodes directly (deterministic — no simulation)
  nodeElements.attr('transform', d => `translate(${d.x},${d.y})`);
}

init();
</script>
</body>
</html>
