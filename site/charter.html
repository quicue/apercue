<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Build Charter — apercue.ca</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible+Mono:ital,wght@0,200..800;1,200..800&family=Atkinson+Hyperlegible+Next:ital,wght@0,200..800;1,200..800&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0a0e14;
  --bg-panel: #0f1319;
  --bg-hover: #151b24;
  --border: #1e2733;
  --border-bright: #2a3545;
  --text: #c5cdd8;
  --text-dim: #5c6978;
  --text-bright: #e8ecf1;
  --accent: #3ddc84;
  --accent-dim: rgba(61, 220, 132, 0.15);

  /* Phase palette — semantic web blue tones + warm progression */
  --phase-1: #5b9cf6;  /* Scaffold — foundation blue */
  --phase-2: #7b6cf6;  /* Patterns — structural purple */
  --phase-3: #c084fc;  /* Projections — output violet */
  --phase-4: #34d1bf;  /* Examples — proof teal */
  --phase-5: #f0c040;  /* Ship — deployment gold */
  --phase-6: #3ddc84;  /* Completeness — the accent green */
  --phase-7: #f09070;  /* Semantic integrity — warm coral */
  --phase-8: #e8b84d;  /* Local hardening — electric amber */

  --body: 'Atkinson Hyperlegible Next', sans-serif;
  --mono: 'Atkinson Hyperlegible Mono', monospace;

  /* Type indicators */
  --type-schema: #5b9cf6;
  --type-pattern: #7b6cf6;
  --type-projection: #c084fc;
  --type-example: #34d1bf;
  --type-documentation: #f0c040;
  --type-ci: #f09070;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: var(--body);
  overflow: hidden;
  height: 100vh;
}

body::before {
  content: '';
  position: fixed;
  inset: 0;
  background-image:
    radial-gradient(circle at 20% 50%, rgba(91, 156, 246, 0.03) 0%, transparent 50%),
    radial-gradient(circle at 80% 30%, rgba(61, 220, 132, 0.03) 0%, transparent 50%),
    radial-gradient(circle, rgba(200, 200, 220, 0.02) 1px, transparent 1px);
  background-size: 100% 100%, 100% 100%, 24px 24px;
  pointer-events: none;
  z-index: 0;
}

.layout {
  display: grid;
  grid-template-columns: 280px 1fr;
  height: 100vh;
  position: relative;
  z-index: 1;
}

/* ── Sidebar ───────────────────────────────── */
.sidebar {
  background: var(--bg-panel);
  border-right: 1px solid var(--border);
  overflow-y: auto;
  scrollbar-width: thin;
  scrollbar-color: var(--border) var(--bg-panel);
}

.sidebar-header {
  padding: 20px;
  border-bottom: 1px solid var(--border);
}

.sidebar-title {
  font-family: var(--mono);
  font-size: 13px;
  font-weight: 600;
  color: var(--text-bright);
  letter-spacing: 0.02em;
}

.sidebar-subtitle {
  font-family: var(--mono);
  font-size: 10px;
  color: var(--text-dim);
  margin-top: 4px;
  letter-spacing: 0.05em;
  text-transform: uppercase;
}

.status-badge {
  display: inline-block;
  font-family: var(--mono);
  font-size: 10px;
  font-weight: 500;
  padding: 3px 8px;
  border-radius: 2px;
  margin-top: 8px;
  letter-spacing: 0.05em;
}

.status-badge.complete {
  color: var(--accent);
  background: var(--accent-dim);
  border: 1px solid rgba(61, 220, 132, 0.25);
}

.status-badge.incomplete {
  color: #f0c040;
  background: rgba(240, 192, 64, 0.15);
  border: 1px solid rgba(240, 192, 64, 0.25);
}

/* Metrics */
.metrics {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1px;
  background: var(--border);
  border-bottom: 1px solid var(--border);
}

.metric {
  background: var(--bg-panel);
  padding: 12px 16px;
  text-align: center;
}

.metric-value {
  font-family: var(--mono);
  font-size: 20px;
  font-weight: 600;
  color: var(--text-bright);
}

.metric-label {
  font-size: 10px;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  margin-top: 2px;
}

/* Gate timeline */
.section-label {
  font-family: var(--mono);
  font-size: 10px;
  font-weight: 500;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.1em;
  padding: 16px 20px 8px;
}

.gate-list {
  list-style: none;
  padding: 0 20px 16px;
}

.gate-item {
  position: relative;
  padding: 10px 0 10px 24px;
  border-left: 2px solid var(--border);
  margin-left: 6px;
  cursor: pointer;
  transition: background 0.15s;
}

.gate-item:hover { background: var(--bg-hover); margin: 0 -20px; padding-left: 44px; padding-right: 20px; }

.gate-item:last-child { border-left-color: transparent; }

.gate-item::before {
  content: '';
  position: absolute;
  left: -7px;
  top: 14px;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  border: 2px solid var(--border);
  background: var(--bg-panel);
  transition: all 0.2s;
}

.gate-item.satisfied::before {
  border-color: var(--accent);
  background: var(--accent);
  box-shadow: 0 0 8px rgba(61, 220, 132, 0.3);
}

.gate-item .gate-phase {
  font-family: var(--mono);
  font-size: 10px;
  color: var(--text-dim);
  letter-spacing: 0.05em;
}

.gate-item .gate-name {
  font-size: 13px;
  font-weight: 500;
  color: var(--text-bright);
  margin-top: 2px;
}

.gate-item .gate-desc {
  font-size: 11px;
  color: var(--text-dim);
  margin-top: 2px;
}

.gate-item .gate-count {
  font-family: var(--mono);
  font-size: 10px;
  color: var(--text-dim);
  margin-top: 4px;
}

/* W3C specs sidebar */
.specs-list {
  list-style: none;
  padding: 0 20px 16px;
}

.spec-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 0;
  font-size: 12px;
}

.spec-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  flex-shrink: 0;
}

.spec-dot.impl { background: var(--accent); }
.spec-dot.ns { background: var(--text-dim); }
.spec-dot.downstream { background: var(--phase-3); }

.spec-name { color: var(--text); }
.spec-prefix {
  font-family: var(--mono);
  font-size: 10px;
  color: var(--text-dim);
}

/* Legend */
.legend {
  padding: 0 20px 20px;
}

.legend-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 6px;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  color: var(--text-dim);
}

.legend-swatch {
  width: 10px;
  height: 10px;
  border-radius: 2px;
  flex-shrink: 0;
}

/* ── Graph area ────────────────────────────── */
.graph-container {
  position: relative;
  overflow: hidden;
}

.graph-container svg {
  width: 100%;
  height: 100%;
}

/* Phase lane labels */
.phase-label {
  font-family: var(--mono);
  font-size: 10px;
  fill: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.1em;
  opacity: 0.5;
}

.phase-divider {
  stroke: var(--border);
  stroke-dasharray: 4,4;
  opacity: 0.3;
}

/* Edges */
.edge {
  stroke: var(--border);
  stroke-width: 1;
  fill: none;
  opacity: 0.4;
  transition: opacity 0.2s, stroke 0.2s;
}

.edge.highlighted {
  stroke: var(--accent);
  stroke-width: 1.5;
  opacity: 0.8;
}

.edge.faded { opacity: 0.08; }

.edge.critical {
  stroke: var(--accent);
  stroke-width: 2;
  opacity: 0.7;
  stroke-dasharray: 6 3;
  animation: dash-flow 1.5s linear infinite;
}

@keyframes dash-flow {
  to { stroke-dashoffset: -18; }
}

.node.critical circle {
  filter: drop-shadow(0 0 6px var(--accent));
}

/* Nodes */
.node { cursor: pointer; }

.node circle {
  stroke-width: 2;
  transition: r 0.2s, stroke-width 0.2s;
}

.node.faded circle { opacity: 0.15; }
.node.faded text { opacity: 0.1; }
.node.planned circle { stroke-dasharray: 4 3; opacity: 0.5; }
.node.planned text { opacity: 0.4; }

.node text {
  font-family: var(--mono);
  font-size: 9px;
  fill: var(--text);
  text-anchor: middle;
  pointer-events: none;
  transition: opacity 0.2s;
}

.node:hover circle {
  stroke-width: 3;
  filter: drop-shadow(0 0 6px currentColor);
}

/* Tooltip */
.tooltip {
  position: absolute;
  background: var(--bg-panel);
  border: 1px solid var(--border-bright);
  border-radius: 4px;
  padding: 12px 16px;
  font-size: 12px;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.15s;
  max-width: 280px;
  z-index: 10;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
}

.tooltip.visible { opacity: 1; }

.tooltip-name {
  font-family: var(--mono);
  font-weight: 600;
  color: var(--text-bright);
  font-size: 13px;
}

.tooltip-type {
  font-family: var(--mono);
  font-size: 10px;
  margin-top: 4px;
}

.tooltip-type span {
  display: inline-block;
  padding: 1px 6px;
  border-radius: 2px;
  margin-right: 4px;
}

.tooltip-desc {
  color: var(--text-dim);
  margin-top: 6px;
  line-height: 1.5;
}

.tooltip-meta {
  font-family: var(--mono);
  font-size: 10px;
  color: var(--text-dim);
  margin-top: 6px;
  padding-top: 6px;
  border-top: 1px solid var(--border);
}

/* Nav links */
.nav-links {
  padding: 12px 20px;
  border-top: 1px solid var(--border);
  display: flex;
  gap: 16px;
}

.nav-links a {
  font-family: var(--mono);
  font-size: 11px;
  color: var(--text-dim);
  text-decoration: none;
  border-bottom: 1px solid transparent;
  transition: all 0.2s;
}

.nav-links a:hover {
  color: var(--accent);
  border-bottom-color: var(--accent);
}

/* Arrowhead marker */
marker path { fill: var(--border); }
marker.highlighted path { fill: var(--accent); }
</style>
</head>
<body>
<div class="layout">

<!-- ═══ SIDEBAR ════════════════════════════════════════════ -->
<aside class="sidebar">
  <div class="sidebar-header">
    <div class="sidebar-title">apercue build charter</div>
    <div class="sidebar-subtitle">W3C Linked Data &middot; CUE Projections</div>
    <div id="status-badge"></div>
  </div>

  <div class="metrics" id="metrics"></div>

  <div class="section-label">Phase Gates</div>
  <ul class="gate-list" id="gate-list"></ul>

  <div class="section-label">W3C Coverage</div>
  <ul class="specs-list" id="specs-list"></ul>

  <div class="section-label">Types</div>
  <div class="legend" id="legend"></div>

  <div class="nav-links">
    <a href="index.html">Home</a>
    <a href="explorer.html">Ecosystem</a>
    <a href="projections.html">Projections</a>
    <a href="spec/index.html">Spec</a>
  </div>
</aside>

<!-- ═══ GRAPH ═════════════════════════════════════════════ -->
<div class="graph-container" id="graph-area">
  <svg id="graph-svg"></svg>
  <div class="tooltip" id="tooltip"></div>
</div>

</div>

<script>
const DATA_URL = 'data/charter.json';
const SPECS_URL = 'data/specs.json';

const PHASE_COLORS = {
  1: '#5b9cf6', 2: '#7b6cf6', 3: '#c084fc',
  4: '#34d1bf', 5: '#f0c040', 6: '#3ddc84', 7: '#f09070',
  8: '#e8b84d'
};

const PHASE_NAMES = {
  1: 'Scaffold + Vocab', 2: 'Core Patterns', 3: 'W3C Projections',
  4: 'Examples', 5: 'Docs + Deploy', 6: 'Projection Completeness',
  7: 'Semantic Integrity', 8: 'Local Hardening'
};

const TYPE_COLORS = {
  Schema: '#5b9cf6', Pattern: '#7b6cf6', Projection: '#c084fc',
  Example: '#34d1bf', Documentation: '#f0c040', CI: '#f09070'
};

function primaryType(types) {
  const order = ['Schema','Pattern','Projection','Example','Documentation','CI'];
  for (const t of order) if (types.includes(t)) return t;
  return types[0] || 'Schema';
}

async function init() {
  let data, specs;
  try {
    [data, specs] = await Promise.all([
      fetch(DATA_URL).then(r => r.json()),
      fetch(SPECS_URL).then(r => r.json()).catch(() => null)
    ]);
  } catch(e) {
    console.error('Failed to load data:', e);
    return;
  }

  // Build lookup for planned status (used by sidebar + graph)
  window.nodeMap = {};
  data.nodes.forEach(n => { nodeMap[n.id] = n; });

  // Build critical path set from scheduling data
  window.criticalSet = new Set();
  if (data.scheduling && data.scheduling.critical_sequence) {
    data.scheduling.critical_sequence.forEach(s => criticalSet.add(s.resource));
  }

  renderSidebar(data, specs);
  renderGraph(data);
}

function renderSidebar(data, specs) {
  // Status badge
  const badge = document.getElementById('status-badge');
  const complete = data.charter_summary.complete;
  const nextGate = data.charter_summary.next_gate;
  badge.innerHTML = `<span class="status-badge ${complete ? 'complete' : 'incomplete'}">${
    complete ? 'ALL GATES SATISFIED' : `NEXT: ${nextGate}`
  }</span>`;

  // Metrics
  const m = document.getElementById('metrics');
  const totalEdges = data.edges.length;
  const maxDepth = Math.max(...data.nodes.map(n => n.depth));
  const totalGates = Object.keys(data.gates).length;
  const satisfiedGates = Object.values(data.gates).filter(g => g.satisfied).length;
  const cpmSummary = data.scheduling && data.scheduling.summary;
  const metrics = [
    [data.charter_summary.deliverables, 'Resources'],
    [totalEdges, 'Edges'],
    [`${satisfiedGates}/${totalGates}`, 'Gates'],
  ];
  if (cpmSummary) {
    metrics.push([cpmSummary.critical_count, 'Critical Path']);
  } else {
    metrics.push([maxDepth, 'Max Depth']);
  }
  m.innerHTML = metrics.map(([v,l]) =>
    `<div class="metric"><div class="metric-value">${v}</div><div class="metric-label">${l}</div></div>`
  ).join('');

  // Gate timeline
  const gl = document.getElementById('gate-list');
  const sortedGates = Object.entries(data.gates).sort((a,b) => a[1].phase - b[1].phase);
  gl.innerHTML = sortedGates.map(([name, gate]) => {
    const color = PHASE_COLORS[gate.phase] || '#5b9cf6';
    return `<li class="gate-item ${gate.satisfied ? 'satisfied' : ''}" data-gate="${name}"
                style="${gate.satisfied ? '' : `--gate-color: ${color}`}">
      <div class="gate-phase" style="color: ${color}">Phase ${gate.phase}</div>
      <div class="gate-name">${name}</div>
      <div class="gate-desc">${gate.description}</div>
      <div class="gate-count">${gate.resources.length} resources${gate.satisfied ? '' : (() => {
        const planned = gate.resources.filter(r => nodeMap[r] && nodeMap[r].planned).length;
        return planned > 0 ? ` · ${planned} planned` : '';
      })()}</div>
    </li>`;
  }).join('');

  // Gate hover → highlight resources
  gl.querySelectorAll('.gate-item').forEach(el => {
    el.addEventListener('mouseenter', () => {
      const gateName = el.dataset.gate;
      const resources = new Set(data.gates[gateName].resources);
      highlightNodes(resources);
    });
    el.addEventListener('mouseleave', clearHighlight);
  });

  // W3C specs
  if (specs) {
    const sl = document.getElementById('specs-list');
    const statusOrder = { Implemented: 0, Namespace: 1, Downstream: 2 };
    const sorted = Object.entries(specs).sort((a,b) =>
      (statusOrder[a[1].status] || 3) - (statusOrder[b[1].status] || 3)
    );
    sl.innerHTML = sorted.map(([name, s]) => {
      const cls = s.status === 'Implemented' ? 'impl' : s.status === 'Namespace' ? 'ns' : 'downstream';
      return `<li class="spec-item">
        <span class="spec-dot ${cls}"></span>
        <span class="spec-name">${s.spec_name}</span>
        ${s.prefix ? `<span class="spec-prefix">${s.prefix}:</span>` : ''}
      </li>`;
    }).join('');
  }

  // Legend
  const lg = document.getElementById('legend');
  lg.innerHTML = '<div class="legend-grid">' +
    Object.entries(TYPE_COLORS).map(([t, c]) =>
      `<div class="legend-item"><span class="legend-swatch" style="background:${c}"></span>${t}</div>`
    ).join('') + '</div>';
}

let nodeElements, edgeElements;

function highlightNodes(nameSet) {
  if (!nodeElements) return;
  nodeElements.classed('faded', d => !nameSet.has(d.id));
  edgeElements.classed('faded', d => !nameSet.has(d.source.id || d.source) && !nameSet.has(d.target.id || d.target));
  edgeElements.classed('highlighted', d => nameSet.has(d.source.id || d.source) && nameSet.has(d.target.id || d.target));
}

function clearHighlight() {
  if (!nodeElements) return;
  nodeElements.classed('faded', false);
  edgeElements.classed('faded', false).classed('highlighted', false);
}

function renderGraph(data) {
  const container = document.getElementById('graph-area');
  const svg = d3.select('#graph-svg');
  const width = container.clientWidth;
  const height = container.clientHeight;

  svg.attr('viewBox', [0, 0, width, height]);

  // Arrow marker
  svg.append('defs').append('marker')
    .attr('id', 'arrow')
    .attr('viewBox', '0 -4 8 8')
    .attr('refX', 16).attr('refY', 0)
    .attr('markerWidth', 6).attr('markerHeight', 6)
    .attr('orient', 'auto')
    .append('path').attr('d', 'M0,-3L7,0L0,3').attr('fill', '#2a3545');

  const g = svg.append('g');

  // Zoom
  const zoom = d3.zoom()
    .scaleExtent([0.3, 4])
    .on('zoom', e => g.attr('transform', e.transform));
  svg.call(zoom);

  // Deterministic layered layout — depth on Y axis, siblings spread on X
  const maxDepth = Math.max(...data.nodes.map(n => n.depth));
  const marginY = 80;
  const layerH = (height - marginY * 2) / Math.max(maxDepth, 1);

  // Group by depth for layout
  const depthGroups = {};
  data.nodes.forEach(n => {
    if (!depthGroups[n.depth]) depthGroups[n.depth] = [];
    depthGroups[n.depth].push(n);
  });

  // Phase lane backgrounds
  const phaseDepthRanges = {};
  data.nodes.forEach(n => {
    if (!phaseDepthRanges[n.phase]) phaseDepthRanges[n.phase] = [Infinity, -Infinity];
    phaseDepthRanges[n.phase][0] = Math.min(phaseDepthRanges[n.phase][0], n.depth);
    phaseDepthRanges[n.phase][1] = Math.max(phaseDepthRanges[n.phase][1], n.depth);
  });

  Object.entries(phaseDepthRanges).forEach(([phase, [minD, maxD]]) => {
    const y1 = marginY + minD * layerH - layerH * 0.4;
    const y2 = marginY + maxD * layerH + layerH * 0.4;
    const color = PHASE_COLORS[phase] || '#5b9cf6';

    g.append('rect')
      .attr('x', 20).attr('y', y1)
      .attr('width', width - 40).attr('height', y2 - y1)
      .attr('rx', 4)
      .attr('fill', color).attr('opacity', 0.02);

    g.append('text')
      .attr('class', 'phase-label')
      .attr('x', 32).attr('y', y1 + 14)
      .attr('fill', color)
      .text(`Phase ${phase} — ${PHASE_NAMES[phase] || ''}`);
  });

  // Deterministic layout — fixed positions, no simulation jitter
  data.nodes.forEach(n => {
    const group = depthGroups[n.depth];
    const idx = group.indexOf(n);
    const count = group.length;
    const spacing = Math.min((width - 80) / (count + 1), 140);
    const startX = (width - (count - 1) * spacing) / 2;
    n.x = startX + idx * spacing;
    n.y = marginY + n.depth * layerH;
  });

  // Resolve edge endpoints to node objects
  const nodeById = {};
  data.nodes.forEach(n => { nodeById[n.id] = n; });
  data.edges.forEach(e => {
    if (typeof e.source === 'string') e.source = nodeById[e.source];
    if (typeof e.target === 'string') e.target = nodeById[e.target];
  });

  // Edges — Bezier curves following dependency flow
  edgeElements = g.append('g')
    .selectAll('path')
    .data(data.edges)
    .join('path')
    .attr('class', d => {
      const s = d.source.id || d.source;
      const t = d.target.id || d.target;
      return 'edge' + (criticalSet.has(s) && criticalSet.has(t) ? ' critical' : '');
    })
    .attr('marker-end', 'url(#arrow)')
    .attr('d', d => {
      const dx = d.target.x - d.source.x;
      const dy = d.target.y - d.source.y;
      const cx = d.source.x + dx * 0.5;
      const cy1 = d.source.y + dy * 0.3;
      const cy2 = d.source.y + dy * 0.7;
      return `M${d.source.x},${d.source.y} C${cx},${cy1} ${cx},${cy2} ${d.target.x},${d.target.y}`;
    });

  // Nodes
  nodeElements = g.append('g')
    .selectAll('g')
    .data(data.nodes)
    .join('g')
    .attr('class', d => 'node' + (d.planned ? ' planned' : '') + (criticalSet.has(d.id) ? ' critical' : ''));

  nodeElements.append('circle')
    .attr('r', d => d.depth === 0 ? 14 : d.types.length > 1 ? 11 : 9)
    .attr('fill', d => {
      const color = PHASE_COLORS[d.phase] || '#5b9cf6';
      return d.planned ? 'transparent' : color + '20';
    })
    .attr('stroke', d => TYPE_COLORS[primaryType(d.types)] || '#5b9cf6')
    .style('color', d => TYPE_COLORS[primaryType(d.types)] || '#5b9cf6');

  nodeElements.append('text')
    .attr('dy', d => (d.depth === 0 ? 14 : d.types.length > 1 ? 11 : 9) + 14)
    .text(d => d.name.length > 18 ? d.name.substring(0, 16) + '…' : d.name);

  // Tooltip
  const tooltip = document.getElementById('tooltip');
  nodeElements.on('mouseenter', (e, d) => {
    const typeSpans = d.types.map(t => {
      const c = TYPE_COLORS[t] || '#5b9cf6';
      return `<span style="background:${c}20;color:${c};border:1px solid ${c}40">${t}</span>`;
    }).join('');

    const kbHtml = d.kb && d.kb.length > 0
      ? `<div class="tooltip-meta">${d.kb.map(k => `<span style="opacity:0.7">${k.type.toUpperCase()}</span> ${k.title}`).join('<br>')}</div>`
      : '';

    const slackLabel = d.slack === 0
      ? '<span style="color:var(--accent)">CRITICAL</span>'
      : `Slack ${d.slack}`;

    tooltip.innerHTML = `
      <div class="tooltip-name">${d.name}</div>
      <div class="tooltip-type">${typeSpans}</div>
      <div class="tooltip-desc">${d.description}</div>
      <div class="tooltip-meta">
        Phase ${d.phase} · ${d.gate} · Depth ${d.depth}${d.planned ? ' · PLANNED' : ''}
      </div>
      <div class="tooltip-meta">
        ES ${d.earliest} → EF ${d.earliest + d.duration} · LS ${d.latest} → LF ${d.latest + d.duration} · ${slackLabel}
      </div>${kbHtml}`;
    tooltip.classList.add('visible');

    // Highlight connected
    const connected = new Set([d.id]);
    data.edges.forEach(edge => {
      const s = edge.source.id || edge.source;
      const t = edge.target.id || edge.target;
      if (s === d.id) connected.add(t);
      if (t === d.id) connected.add(s);
    });
    highlightNodes(connected);
  })
  .on('mousemove', e => {
    tooltip.style.left = (e.clientX - 280 + 16) + 'px';
    tooltip.style.top = (e.clientY - 10) + 'px';
  })
  .on('mouseleave', () => {
    tooltip.classList.remove('visible');
    clearHighlight();
  });

  // Position nodes directly (deterministic — no simulation)
  nodeElements.attr('transform', d => `translate(${d.x},${d.y})`);
}

init();
</script>
</body>
</html>
